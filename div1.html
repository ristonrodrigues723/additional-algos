<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brute Force Tree Search Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
    body {
    font-family: "Poppins", sans-serif;
    background-color: rgb(231, 231, 231);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
}

.container {
    width: 100%;
    max-width: 1000px;
    background-color: white;
    box-shadow: 8px 8px 20px rgb(128, 128, 128);
    border-radius: 20px;
    padding: 20px;
    display: flex;
    flex-direction: column;
}

.heading {
    color: #3498db;
    text-align: center;
    margin-bottom: 20px;
}

#tree-container {
    width: 100%;
    height: 400px;
    border: 1px solid #ccc;
    overflow: auto;
}

#tree-svg {
    width: 100%;
    height: 100%;
    min-width: 600px;
    min-height: 400px;
}

.node-circle {
    fill: #3498db;
    stroke: rgb(3, 3, 3);
    stroke-width: 2;
    transition: all 0.3s ease-in-out;
}

.node-text {
    font-size: 14px;
    text-anchor: middle;
    dominant-baseline: central;
    fill: white;
    pointer-events: none;
}

.node-circle.visited {
    fill: #4CAF50;
    animation: pulse 0.5s ease-in-out;
}

.node-circle.current {
    fill: #FFC107;
    animation: shake 0.5s ease-in-out;
}

.node-circle.found {
    fill: #E1BEE7;
    animation: celebrate 0.5s ease-in-out;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-3px); }
    50% { transform: translateX(3px); }
    75% { transform: translateX(-3px); }
    100% { transform: translateX(0); }
}

@keyframes celebrate {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
}

button, input {
    height: 40px;
    font-size: 16px;
    padding: 0 15px;
    border: none;
    border-radius: 5px;
    background-color: #3498db;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s;
}

button:hover {
    background-color: #2980b9;
}

input[type="text"], input[type="number"] {
    background-color: white;
    color: #333;
    border: 1px solid #3498db;
}

.stats {
    margin-top: 20px;
    text-align: center;
}
     </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="text" id="searchInput" placeholder="Enter search value">
            <button id="searchBtn">Search</button>
            <button id="resetBtn">Reset</button>
            <input type="range" id="speedSlider" min="100" max="2000" value="500">
            <button id="stepBtn">Step</button>
            <input type="number" id="treeDepth" value="3" min="1" max="5">
            <button id="generateTreeBtn">Generate Tree</button>
        </div>
        <div id="tree" class="tree"></div>
        <div class="stats">
            <p>Nodes checked: <span id="nodesChecked">0</span></p>
            <p>Search time: <span id="searchTime">0</span> ms</p>
        </div>
    </div>

    <script>
let currentTree;
let svg;
let isSearching = false;
let nodesChecked = 0;
let startTime;


function initializeTree() {
    const treeContainer = document.getElementById('tree');
    treeContainer.innerHTML = '';

    svg = d3.select(treeContainer)
        .append("svg")
        .attr("width", "100%")
        .attr("height", "400")
        .attr("id", "tree-svg");

    const depth = parseInt(document.getElementById('treeDepth').value);
    currentTree = generateRandomBinaryTree(depth);
    drawTree(currentTree);
}

function generateRandomBinaryTree(depth) {
    if (depth === 0) return null;
    const root = { value: Math.floor(Math.random() * 100), left: null, right: null };
    root.left = generateRandomBinaryTree(depth - 1);
    root.right = generateRandomBinaryTree(depth - 1);
    return root;
}

function drawTree(root) {
    const treeLayout = d3.tree().size([300, 300]);
    const rootNode = d3.hierarchy(root);
    const treeData = treeLayout(rootNode);

    const nodes = treeData.descendants();
    const links = treeData.links();

    svg.selectAll('.link')
        .data(links)
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d3.linkVertical()
            .x(d => d.x)
            .y(d => d.y));

    const node = svg.selectAll('.node')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x},${d.y})`);

    node.append('circle')
        .attr('r', 20)
        .attr('class', 'node-content');

    node.append('text')
        .attr('dy', '0.35em')
        .attr('text-anchor', 'middle')
        .text(d => d.data.value);
}

async function performBruteForceSearch() {
    if (isSearching) return;
    isSearching = true;
    const searchValue = parseInt(document.getElementById('searchInput').value);
    nodesChecked = 0;
    startTime = performance.now();

    const result = await bruteForceSearch(currentTree, searchValue);

    const endTime = performance.now();
    updateStats(nodesChecked, endTime - startTime);
    isSearching = false;

    if (result) {
        console.log("Value found!");
    } else {
        console.log("Value not found in the tree.");
    }
}

async function bruteForceSearch(node, searchValue) {
    if (!node) return false;

    nodesChecked++;
    updateNodeStyle(node, 'current');
    await sleep(getSearchSpeed());

    if (node.value === searchValue) {
        updateNodeStyle(node, 'found');
        return true;
    }

    updateNodeStyle(node, 'visited');

    const leftResult = await bruteForceSearch(node.left, searchValue);
    if (leftResult) return true;

    const rightResult = await bruteForceSearch(node.right, searchValue);
    if (rightResult) return true;

    return false;
}

function updateNodeStyle(node, className) {
    svg.selectAll('.node-content')
        .filter(d => d.data === node)
        .attr('class', `node-content ${className}`);
}

function resetSearch() {
    svg.selectAll('.node-content')
        .attr('class', 'node-content');
    updateStats(0, 0);
}

function updateStats(nodesChecked, searchTime) {
    document.getElementById('nodesChecked').textContent = nodesChecked;
    document.getElementById('searchTime').textContent = searchTime.toFixed(2);
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function getSearchSpeed() {
    return parseInt(document.getElementById('speedSlider').value);
}

document.getElementById('searchBtn').addEventListener('click', performBruteForceSearch);
document.getElementById('resetBtn').addEventListener('click', resetSearch);
document.getElementById('generateTreeBtn').addEventListener('click', initializeTree);

initializeTree();
    </script>
</body>
</html>